### 12
spring boot书籍->书籍中问题点->博客->下载离线
*** 
* idea的springboot initialization，spring官网的来创建springboot项目( https://start.spring.io)
* 在serch for dependency输入web，即可完成基本的restful接口网关的功能，如果要JPA或者oauth安全相关的组件，可以增加rest repository、spring security等相关组件依赖库
* 使用阿里云的maven镜像服务器，或者使用公司的maven私服
<mirror>
    <id>nexus-aliyun</id>
    <mirrorOf>*</mirrorOf>
    <name>Nexus aliyun</name>
    <url>http://maven.aliyun.com/nexus/content/groups/public</url>
</mirror>
* springboot集成了Tomcat和Jetty，默认使用Tomcat作为应用容器，开发者只需要将工程打成jar包直接丢到服务器上就可以执行了，不需要再单独部署到was、jboss、tomcat这些应用服务器上
* 使用chrome的postman或者使用firefox的httprequester插件
* 与Go语言的应用不同，我们知道所有的Java Web应用都必须放在servlet容器（不是像docker容器的那种容器），如Tomcat、Jetty等。Servlet容器被定位为托管web应用程序的高可用组件
* Spring是一套Java开发框架，框架的作用就是为了减少代码的冗余和模块之间的偶尔，使代码逻辑更加清晰，主要是用了AOP（Aspect Oriented Programming，面向切面编程）和IoC（Inversion of Control，控制反转）容器的思想
* org.springframework.aop.framework.ProxyFactoryBean
* new FileSystemXmlApplicationContext
* 使用springboot命令创建Spring Boot应用: brew tap pivotal/tap   brew install springboot
* spring init --build maven --groupId com.example --version 0.0.1-SNAPSHOT --java-version 1.8 --dependencies web --name myproject myproject
* mvn spring-boot:run
* mvn dependency:tree

* spring-boot-starter
* spring-boot-starter-amqp
* spring-boot-starter-aop
* spring-boot-starter-batch
* spring-boot-starter-data-jpa
* spring-boot-starter-data-mongodb
* spring-boot-starter-data-rest
* spring-boot-starter-jdbc
* spring-boot-starter-security
* spring-boot-starter-test
* spring-boot-starter-velocity
* spring-boot-starter-web
* spring-boot-starter-websocket
* spring-boot-starter-ws
* spring-boot-starter-actuator
* spring-boot-starter-remote-shell
* spring-boot-starter-jetty
* spring-boot-starter-log4j
* spring-boot-starter-logging
* spring-boot-starter-tomcat

* spring-boot-starter-logging	使用 Spring Boot 默认的日志框架 Logback
* Spring Boot 也提供了不同的选项，比如日志框架可以用 Logback 或 Log4j，应用服务器可以用 Tomcat 或 Jetty
* mvn archetype:generate -DgroupId=com.example -DartifactId=myproject -DarchetypeArtifactId=maven-archetype-webapp -DinteractiveMode=false
* 平常开发过程中项目构建一般用的是maven，该课程项目构建工具是Gradle，是我从来没有接触过的新技术
* https://www.yiibai.com/gradle/  http://services.gradle.org/distributions/  https://www.yiibai.com/thymeleaf/  https://www.yiibai.com/jpa/ https://elasticsearch.cn/book/elasticsearch_definitive_guide_2.x/  https://blog.csdn.net/laoyang360/article/details/52244917 https://blog.csdn.net/u012702547/article/details/54319508 https://blog.csdn.net/code__code/article/details/53885510
* @PersistenceContext 
private EntityManager em;
* public interface UserDao extends Repository<AccountInfo, Long>
*  spring cache
* logback当前分成三个模块：logback-core,logback- classic和logback-access。logback-core是其它两个模块的基础模块。logback-classic是log4j的一个 改良版本。此外logback-classic完整实现SLF4J API使你可以很方便地更换成其它日志系统如log4j或JDK14 Logging。 
logback-access访问模块与Servlet容器集成提供通过Http来访问日志的功能
* 由于SpringBoot自动引入了logback的依赖包
* 整个项目的核心文件是logback.xml，logback.xml需要放到classpath根目录下src/main/resources/logback.xml
* 在日常开发中发生了异常，往往是需要通过一个统一的异常处理处理所有异常，来保证客户端能够收到友好的提示。SpringBoot在页面 
发生异常的时候会自动把请求转到/error，SpringBoot内置了一个BasicErrorController对异常进行统一的处理，当然也可以自定义这个路径
* server:
  port: 8080
  error:
    path: /custom/error
* 通过使用@ControllerAdvice来进行统一异常处理，@ExceptionHandler(value = Exception.class)来指定捕获的异常 
下面针对两种异常进行了特殊处理分别返回页面和json数据，使用这种方式有个局限，无法根据不同的头部返回不同的数据格式，而且无法针对404、403等多种状态进行处理
* @ControllerAdvice
    public class GlobalExceptionHandler {
        public static final String DEFAULT_ERROR_VIEW = "error";
        @ExceptionHandler(value = CustomException.class)
        @ResponseBody
        public ResponseEntity defaultErrorHandler(HttpServletRequest req, CustomException e) throws Exception {
            return ResponseEntity.ok("ok");
        }
        @ExceptionHandler(value = Exception.class)
        public ModelAndView defaultErrorHandler(HttpServletRequest req, Exception e) throws Exception {
            ModelAndView mav = new ModelAndView();
            mav.addObject("exception", e);
            mav.addObject("url", req.getRequestURL());
            mav.setViewName(DEFAULT_ERROR_VIEW);
            return mav;
        }
    }
* SpringBoot提供了一种特殊的Bean定义方式，可以让我们容易的覆盖已经定义好的Controller,原生的BasicErrorController是定义在ErrorMvcAutoConfiguration
* @Configuration
    @ConditionalOnWebApplication
    @ConditionalOnClass({Servlet.class, DispatcherServlet.class})
    @AutoConfigureBefore(WebMvcAutoConfiguration.class)
    @EnableConfigurationProperties(ResourceProperties.class)
* @Bean
        public MyBasicErrorController basicErrorController(ErrorAttributes errorAttributes) {
            return new MyBasicErrorController(errorAttributes, this.serverProperties.getError(),
                    this.errorViewResolvers);
        }
* MyBasicErrorController不能被自定义扫描Controller扫描到，否则无法启动
* 一般来说自定义BasicErrorController这种方式比较实用，因为可以通过不同的头部返回不同的数据格式，在配置上稍微复杂一些，但是从实用的角度来说比较方便而且可以定义通用组件
* 通过UID分片的形式来存储，不同UID分布在不同的Server上认证
* <groupId>org.springframework.session</groupId>
                <artifactId>spring-session</artifactId>
* <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-redis</artifactId>
* 通过加上@EnableRedisHttpSession注解，开启redis集中式session管理，所有的session都存放到了redis中
* 通过redis集中式管理session这种方式在使用上面对客户端是透明的，无需自己操作redis，在使用HttpSession对象的时候直接使用即可
* SpringBoot提供了一个maven插件来支持热部署spring-boot-devtools,仅仅是在开发环境中使用，如果已经打包了就无法使用
* <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <optional>true</optional>
*  <plugin>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-maven-plugin</artifactId>
                    <version>1.4.1.RELEASE</version>
                    <configuration>
                        <fork>true</fork>
                    </configuration>
                </plugin>
* 喜欢热部署推荐使用 JRebel这个有个人免费版本
* 如果你不想编译，可以指定监控目录一旦目录文件改变，就会触发重新加载
* spring:
  devtools:
    restart:
      additional-paths:
        src/main/java/com/start
* 让你专注于你的自己的业务开发，而不是各种配置
* @Bean
	public CommandLineRunner commandLineRunner(ApplicationContext ctx) {
		return args -> {

			System.out.println("Let's inspect the beans provided by Spring Boot:");

			String[] beanNames = ctx.getBeanDefinitionNames();
			Arrays.sort(beanNames);
			for (String beanName : beanNames) {
				System.out.println(beanName);
			}

		};
	}
* @RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@LocalServerPort
    private int port;
    @Autowired
    private TestRestTemplate template;
* my:
 name: forezp
 age: 12
 number:  ${random.int}
* @ConfigurationProperties(prefix = "my")
@EnableConfigurationProperties({ConfigBean.class})
* @Configuration
@PropertySource(value = "classpath:test.properties")
@ConfigurationProperties(prefix = "com.forezp")
* <groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-jdbc</artifactId>
* jdbcTemplate.update("insert into account(name, money) values(?, ?)",
              account.getName(),account.getMoney());
* List<Account> list = jdbcTemplate.query("select * from account where id = ?", new Object[]{id}, new BeanPropertyRowMapper(Account.class));
* <groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-jpa</artifactId>
* jpa:
    hibernate:
      ddl-auto: update  # 第一次简表create  后面用update
    show-sql: true
* 数据访问层，通过编写一个继承自 JpaRepository 的接口就能完成数据访问,其中包含了几本的单表查询的方法，非常的方便。值得注意的是，这个Account 对象名，而不是具体的表名，另外Interger是主键的类型，一般为Integer或者Long
* public interface AccountDao  extends JpaRepository<Account,Integer> {
}
* BeetSql是一个全功能DAO工具， 同时具有Hibernate 优点 & Mybatis优点功能，适用于承认以SQL为中心，同时又需求工具能自动能生成大量常用的SQL的应用
  * <groupId>com.ibeetl</groupId>
			<artifactId>beetl</artifactId>
* <groupId>com.ibeetl</groupId>
			<artifactId>beetlsql</artifactId>
* <groupId>org.mybatis.spring.boot</groupId>
			<artifactId>mybatis-spring-boot-starter<artifactId>
* @Mapper
public interface AccountMapper {
* springboot开启事务很简单，只需要一个注解@Transactional 就可以了。因为在springboot中已经默认对jpa、jdbc、mybatis开启了事事务，引入它们依赖的时候，事物就默认开启。当然，如果你需要用其他的orm，比如beatlsql，就需要自己配置相关的事物管理器。
* <groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-mongodb</artifactId>
* spring.data.mongodb.uri=mongodb://localhost:27017/springboot-db
* spring.data.mongodb.uri=mongodb://name:pass@localhost:27017/dbname
* public interface CustomerRepository extends MongoRepository<Customer, String> {

    public Customer findByFirstName(String firstName);
    public List<Customer> findByLastName(String lastName);

}
* spring.redis.host=localhost
spring.redis.port=6379
#spring.redis.password=
spring.redis.database=1
spring.redis.pool.max-active=8
spring.redis.pool.max-wait=-1
spring.redis.pool.max-idle=500
spring.redis.pool.min-idle=0
spring.redis.timeout=0
* 用spring官方推荐的restdoc去生成api文档
* <groupId>org.springframework.restdocs</groupId>
			<artifactId>spring-restdocs-mockmvc</artifactId>
* Collections.singletonMap("message", "Hello World");
* restdocs是通过单元测试生存snippets文件，然后snippets根据插件生成htm文档的
* @WebMvcTest(HomeController.class)
@AutoConfigureRestDocs(outputDir = "target/snippets")
* this.mockMvc.perform(get("/")).andDo(print()).andExpect(status().isOk())
                .andExpect(content().string(containsString("Hello World")))
                .andDo(document("home"));
* <plugin>
    <groupId>org.asciidoctor</groupId>
    <artifactId>asciidoctor-maven-plugin</artifactId>
    <executions>
        <execution>
            <id>generate-docs</id>
            <phase>prepare-package</phase>
            <goals>
                <goal>process-asciidoc</goal>
            </goals>
            <configuration>
                <sourceDocumentName>index.adoc</sourceDocumentName>
                <backend>html</backend>
                <attributes>
                    <snippets>${project.build.directory}/snippets</snippets>
                </attributes>
            </configuration>
        </execution>
    </executions>
</plugin>
* npm install apidoc -g
* Spring 定义 CacheManager 和 Cache 接口用来统一不同的缓存技术。例如 JCache、 EhCache、 Hazelcast、 Guava、 Redis 等。在使用 Spring 集成 Cache 的时候，我们需要注册实现的 CacheManager 的 Bean
* Spring Boot 为我们自动配置了 JcacheCacheConfiguration、 EhCacheCacheConfiguration、HazelcastCacheConfiguration、GuavaCacheConfiguration、RedisCacheConfiguration、SimpleCacheConfiguratio;在我们不使用其他第三方缓存依赖的时候，springboot自动采用ConcurrenMapCacheManager作为缓存管理器
* <groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-cache</artifactId>
* @EnableCaching @Cacheable("books")
* restTemplate.getForObject(http://gturnquist-quoters.cfapps.io/api/random", String.class)
* spring.http.multipart.max-file-size=128KB
spring.http.multipart.max-request-size=128KB
* MvcUriComponentsBuilder
                                .fromMethodName(FileUploadController.class, "serveFile", path.getFileName().toString())
                                .build().toString()
*  @GetMapping("/files/{filename:.+}")
* return ResponseEntity
                .ok()
                .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\""+file.getFilename()+"\"")
                .body(file)
* @EnableScheduling
* @Scheduled(fixedRate = 5000)
* @Scheduled(initialDelay=1000, fixedRate=5000) ：第一次延迟1秒后执行，之后按fixedRate的规则每5秒执行一次
* <dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-validator</artifactId>
		</dependency>
		<dependency>
			<groupId>org.apache.tomcat.embed</groupId>
			<artifactId>tomcat-embed-el</artifactId>
		</dependency>
* public String checkPersonInfo(@Valid PersonForm personForm, BindingResult bindingResult) {
* public String greetingSubmit(@ModelAttribute Greeting greeting) {
* <groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-mail</artifactId>
* spring.mail.host=smtp.163.com
spring.mail.username=miles02@163.com
spring.mail.password=
spring.mail.port=25
spring.mail.protocol=smtp
spring.mail.default-encoding=UTF-8
* @Autowired
	private JavaMailSenderImpl mailSender;
* SimpleMailMessage simpleMailMessage = new SimpleMailMessage();
		// 设置收件人，寄件人
		simpleMailMessage.setTo(new String[] {"miles02@163.com"});
		simpleMailMessage.setFrom("miles02@163.com");
		simpleMailMessage.setSubject("Spring Boot Mail 邮件测试【文本】");
		simpleMailMessage.setText("这里是一段简单文本。");
		// 发送邮件
		mailSender.send(simpleMailMessage);
* MimeMessage mimeMessage = mailSender.createMimeMessage();
		MimeMessageHelper mimeMessageHelper = new MimeMessageHelper(mimeMessage);
		mimeMessageHelper.setTo("miles02@163.com");
		mimeMessageHelper.setFrom("miles02@163.com");
		mimeMessageHelper.setSubject("Spring Boot Mail 邮件测试【HTML】");

		StringBuilder sb = new StringBuilder();
		sb.append("<html><head></head>");
		sb.append("<body><h1>spring 邮件测试</h1><p>hello!this is spring mail test。</p></body>");
		sb.append("</html>");

		// 启用html
		mimeMessageHelper.setText(sb.toString(), true);
		// 发送邮件
		mailSender.send(mimeMessage);
* MimeMessage mimeMessage = mailSender.createMimeMessage();
		// multipart模式
		MimeMessageHelper mimeMessageHelper = new MimeMessageHelper(mimeMessage, true);
		mimeMessageHelper.setTo("miles02@163.com");
		mimeMessageHelper.setFrom("miles02@163.com");
		mimeMessageHelper.setSubject("Spring Boot Mail 邮件测试【图片】");

		StringBuilder sb = new StringBuilder();
		sb.append("<html><head></head>");
		sb.append("<body><h1>spring 邮件测试</h1><p>hello!this is spring mail test。</p>");
		// cid为固定写法，imageId指定一个标识
		sb.append("<img src=\"cid:imageId\"/></body>");
		sb.append("</html>");

		// 启用html
		mimeMessageHelper.setText(sb.toString(), true);

		// 设置imageId
		FileSystemResource img = new FileSystemResource(new File("E:/1.jpg"));
		mimeMessageHelper.addInline("imageId", img);

		// 发送邮件
		mailSender.send(mimeMessage);
    * MimeMessage mimeMessage = mailSender.createMimeMessage();
		// multipart模式
		MimeMessageHelper mimeMessageHelper = new MimeMessageHelper(mimeMessage, true, "utf-8");
		mimeMessageHelper.setTo("miles02@163.com");
		mimeMessageHelper.setFrom("miles02@163.com");
		mimeMessageHelper.setSubject("Spring Boot Mail 邮件测试【附件】");

		StringBuilder sb = new StringBuilder();
		sb.append("<html><head></head>");
		sb.append("<body><h1>spring 邮件测试</h1><p>hello!this is spring mail test。</p></body>");
		sb.append("</html>");

		// 启用html
		mimeMessageHelper.setText(sb.toString(), true);
		// 设置附件
		FileSystemResource img = new FileSystemResource(new File("E:/1.jpg"));
		mimeMessageHelper.addAttachment("image.jpg", img);

		// 发送邮件
		mailSender.send(mimeMessage);
    * @Async
    public Future<User> findUser(String user) throws InterruptedException {
  * @EnableAsync
  * Docker有一个简单的dockerfile文件作为指定镜像的图层。让我们先创建一个 dockerFile文件
  * <properties>
   <docker.image.prefix>springio</docker.image.prefix>
</properties>
<build>
    <plugins>
        <plugin>
            <groupId>com.spotify</groupId>
            <artifactId>docker-maven-plugin</artifactId>
            <version>0.4.11</version>
            <configuration>
                <imageName>${docker.image.prefix}/${project.artifactId}</imageName>
                <dockerDirectory>src/main/docker</dockerDirectory>
                <resources>
                    <resource>
                        <targetPath>/</targetPath>
                        <directory>${project.build.directory}</directory>
                        <include>${project.build.finalName}.jar</include>
                    </resource>
                </resources>
            </configuration>
        </plugin>
    </plugins>
</build>
* mvn package docker:bulid
* public HttpMessageConverters getHttpMessageConverters(){
        return new WebMvcJSONConfigure().customConverters();
    }
* @ColumnQuery(operate = QueryOperater.LIKE)
* @FeignClient(Services.SERVICE_DB_PERSON)

*** 
spring cloud
*** 
* 微服务架构就是将一个完整的应用从数据存储开始垂直拆分成多个不同的服务，每个服务都能独立部署、独立维护、独立扩展，服务与服务间通过诸如RESTful API的方式互相调用
* 服务发现（Eureka），断路器（Hystrix），智能路有（Zuul），客户端负载均衡（Ribbon）
* @EnableEurekaServer
* eureka.client.register-with-eureka=false
eureka.client.fetch-registry=false
eureka.client.serviceUrl.defaultZone=http://localhost:${server.port}/eureka/
* @EnableDiscoveryClient
* <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-ribbon</artifactId>
* @EnableDiscoveryClient
* @Bean
	@LoadBalanced
	RestTemplate restTemplate() {
		return new RestTemplate();
	}
* restTemplate.getForEntity("http://COMPUTE-SERVICE/add?a=10&b=20", String.class).getBody();
* Feign是一个声明式的Web Service客户端，它使得编写Web Serivce客户端变得更加简单。我们只需要使用Feign来创建一个接口并用注解来配置它既可完成。它具备可插拔的注解支持，包括Feign注解和JAX-RS注解。Feign也支持可插拔的编码器和解码器。Spring Cloud为Feign增加了对Spring MVC注解的支持，还整合了Ribbon和Eureka来提供均衡负载的HTTP客户端实现
* <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-feign</artifactId>
* 在应用主类中通过@EnableFeignClients注解开启Feign功能
* @FeignClient("compute-service")
public interface ComputeClient {
    @RequestMapping(method = RequestMethod.GET, value = "/add")
    Integer add(@RequestParam(value = "a") Integer a, @RequestParam(value = "b") Integer b);
}
* 通过Feign以接口和注解配置的方式，轻松实现了对compute-service服务的绑定，这样我们就可以在本地应用中像本地服务一下的调用它，并且做到了客户端均衡负载
* @HystrixCommand(fallbackMethod = "addServiceFallback")
* @FeignClient(value = "compute-service", fallback = ComputeClientHystrix.class)
* 配置服务器默认采用git来存储配置信息，这样就有助于对环境配置进行版本管理，并且可以通过git客户端工具来方便的管理和访问配置内容
* <groupId>org.springframework.cloud</groupId>
		<artifactId>spring-cloud-config-server</artifactId>
* @EnableConfigServer
* spring.cloud.config.server.git.uri=http://git.oschina.net/didispace/SpringBoot-Learning/
spring.cloud.config.server.git.searchPaths=Chapter9-1-4/config-repo
spring.cloud.config.server.git.username=username
spring.cloud.config.server.git.password=password
* <groupId>org.springframework.cloud</groupId>
		<artifactId>spring-cloud-starter-config</artifactId>
* @RefreshScope
* 设置属性spring.profiles.active=native，Config Server会默认从应用的src/main/resource目录下检索配置文件。也可以通过spring.cloud.config.server.native.searchLocations=file:F:/properties/属性来指定配置文件的位置。虽然Spring Cloud Config提供了这样的功能，但是为了支持更好的管理内容和版本控制的功能，还是推荐使用git的方式
* spring.application.name=didispace
spring.cloud.config.profile=dev
spring.cloud.config.label=master
spring.cloud.config.uri=http://localhost:7001/
* /{application}/{profile}[/{label}]
/{application}-{profile}.yml
/{label}/{application}-{profile}.yml
/{application}-{profile}.properties
/{label}/{application}-{profile}.properties
* eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/
spring.cloud.config.discovery.enabled=true
spring.cloud.config.discovery.serviceId=config-server
spring.cloud.config.profile=dev
* Open Service是一个对外的服务，通过均衡负载公开至服务调用方
* 通过服务网关统一向外系统提供REST API的过程中，除了具备服务路由、均衡负载功能之外，它还具备了权限控制等功能。Spring Cloud Netflix中的Zuul就担任了这样的一个角色，为微服务架构提供了前门保护的作用，同时将权限控制这些较重的非业务逻辑内容迁移到服务路由层面，使得服务集群主体能够具备更高的可复用性和可测试性
*  <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-zuul</artifactId>
* 应用主类使用@EnableZuulProxy注解开启Zuul
* @SpringCloudApplication注解，之前没有提过，通过源码我们看到，它整合了@SpringBootApplication、@EnableDiscoveryClient、@EnableCircuitBreaker
* zuul.routes.api-a-url.path=/api-a-url/**
zuul.routes.api-a-url.url=http://localhost:2222/
* zuul.routes.api-a.path=/api-a/**
zuul.routes.api-a.serviceId=service-A
* 在服务网关中定义过滤器只需要继承ZuulFilter抽象类实现其定义的四个抽象函数就可对请求进行拦截与过滤。
* 定义了一个Zuul过滤器，实现了在请求被路由之前检查请求中是否有accessToken参数，若有就进行路由，若没有就拒绝访问，返回401 Unauthorized错误
* RequestContext ctx = RequestContext.getCurrentContext();
        HttpServletRequest request = ctx.getRequest();
* @Bean
	public AccessFilter accessFilter() {
		return new AccessFilter();
	}
* pre routing post custom error
* 通过服务网关中的过滤器，在各生命周期中去校验请求的内容，将原本在对外服务层做的校验前移，保证了微服务的无状态性，同时降低了微服务的测试难度，让服务本身更集中关注业务逻辑的处理
* spring.application.name=eureka-server
server.port=1111
eureka.instance.hostname=peer1
eureka.client.serviceUrl.defaultZone=http://peer2:1112/eureka/
* 127.0.0.1 peer1
127.0.0.1 peer2
* eureka.client.serviceUrl.defaultZone=http://peer1:1111/eureka/,http://peer2:1112/eureka/
* spring.rabbitmq.host=localhost
spring.rabbitmq.port=5672
spring.rabbitmq.username=springcloud
spring.rabbitmq.password=123456
* 启动config-server-eureka，再启动两个config-client-eureka
* 消息持久化：以时间复杂度为O(1)的方式提供消息持久化能力，即使对TB级以上数据也能保证常数时间复杂度的访问性能。
高吞吐：在廉价的商用机器上也能支持单机每秒100K条以上的吞吐量
分布式：支持消息分区以及分布式消费，并保证分区内的消息顺序
跨平台：支持不同技术平台的客户端（如：Java、PHP、Python等）
实时性：支持实时数据处理和离线数据处理
伸缩性：支持水平扩展
* <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-bus-kafka</artifactId>
* Spring Cloud 是一套完整的微服务解决方案，基于 Spring Boot 框架，准确的说，它不是一个框架，而是一个大的容器，它将市面上较好的微服务框架集成进来，从而简化了开发者的代码量
