linux
---

* 端口使用情况、启用/禁用
* tar、wget、nohup、find
* jdk
* redis
* hdfs
* tomcat
* docker
* nginx
* Jenkins
* rocketmq
* oracle
* mysql
* 把linux用成各种服务器，先把工具用好，再码代码

windows
---

* 查看进程、端口、jps
* 网站开发完成，上线之后，服务器的读写效率是网站运行速度的重要条件，当然还有服务器的带宽
* sql语句的优化技术，网站的处理和访问量非常大的时候，我们的数据库的压力就变大
* 使用高并发处理、负载均衡和分布式数据库，而这些技术既花费人力，又花费资金
* 在开发网站的时候如果有一些数据在短时间之内不会发生变化，而它们还要被频繁访问，为了提高用户的请求速度和降低网站的负载，就把这些数据放到一个读取速度更快的介质上,该介质可以是文件/数据库/内存,页面缓存经常用在CMS(content manage system)内存管理系统里面
* 页面缓存(smarty静态化技术)(第一次读取数据库，然后生成一个静态页面，以后加载这个静态页面)
* Redis是Remote Dictionary Server(远程数据服务)的缩写，由意大利人antirez(Salvatore Sanfilippo)开发的一款内存高速缓存数据库
* 可持久化(一边运行，一边把数据往硬盘中备份一份，防止断电等情况导致数据丢失，等断电情况恢复之后，Redis再把硬盘中的数据恢复到内存中)，保证了数据的安全
* Redis单个value的最大限制是1GB，memcached只能保存1MB的数据
* QPS
* 缓存——热数据  计数器  队列（相当于消息系统，ActiveMQ，RocketMQ等工具类似，对于数据一致性要求高的话还是用RocketMQ等专业系统；redis把数据添加到队列是返回添加元素在队列的第几位，所以可以做判断用户是第几个访问这种业务；队列不仅可以把并发请求变成串行，并且还可以做队列或者栈使用）  
位操作（大数据处理）位操作——使用setbit、getbit、bitcount   redis内构建一个足够长的数组，每个数组元素只能是0和1两个值，然后这个数组的下标index用来表示我们上面例子里面的用户id（必须是数字哈），那么很显然，这个几亿长的大数组就能通过下标和元素值（0和1）来构建一个记忆系统，上面我说的几个场景也就能够实现
* 验证前端的重复请求（可以自由扩展类似情况），可以通过redis进行过滤：每次请求将request Ip、参数、接口等hash作为key存储redis（幂等性请求），设置多长时间有效期，然后下次请求过来的时候先在redis中检索有没有这个key，进而验证是不是一定时间内过来的重复提交
* 秒杀系统，基于redis是单线程特征，防止出现数据库“爆破”   全局增量ID生成，类似“秒杀”
* 闻列表页面最新的新闻列表，如果总数量很大的情况下，尽量不要使用select a from A limit 10这种low货，尝试redis的 LPUSH命令构建List，一个个顺序都塞进去就可以啦。不过万一内存清掉了咋办？也简单，查询不到存储key的话，用mysql查询并且初始化一个List到redis中就好了
* 谁得分高谁排名往上。命令：ZADD（有续集，sorted set）
* 利用list的自然时间排序存储最新n个数据
* redis是一个比较常用的nosql数据库。因其是纯内存操作，所以处理能力十分出色。跟memcache相比支持丰富的数据类型。目前新浪微博大量使用redis存储数据
* 要想使用好这个工具，还需要更深入的对工具进行了解。皮毛的东西、虽然能应付得了工作。但是学不到真正的知识。
* 实际MySQL是适合进行海量数据存储的，通过Memcached将热点数据加载到cache，加速访问，很多公司都曾经使用过这样的架构，但随着业务数据量的不断增加，和访问量的持续增长，我们遇到了很多问题
* MySQL需要不断进行拆库拆表，Memcached也需不断跟着扩容 Memcached与MySQL数据库数据一致性问题 Memcached数据命中率低或down机，大量访问直接穿透到DB，MySQL无法支撑 跨机房cache同步问题
* 在Redis中，你可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能
* Transactions还是提供了基本的命令打包执行的功能（在服务器不出问题的情况下，可以保证一连串的命令是顺序在一起执行的，中间有会有其它客户端命令插进来执行）。Redis还提供了一个Watch功能，你可以对一个key进行Watch，然后再执行Transactions，在这过程中，如果这个Watched的值进行了修改，那么这个Transactions会发现并拒绝执行
* 作为一个电商网站被各种spam攻击是少不免（垃圾评论、发布垃圾商品、广告、刷自家商品排名等），针对这些spam制定一系列anti-spam规则，其中有些规则可以利用redis做实时分析，譬如：1分钟评论不得超过2次、5分钟评论少于5次等（更多机制/规则需要结合drools ）。 采用sorted set将最近一天用户操作记录起来（为什么不全部记录？节省memory，全部操作会记录到log，后续利用hadoop进行更全面分析统计）
* Java编写的游戏、桌面系统、办公软件
* 许多服务器程序都是拿 Java 来编写以处理每天超过数以千万的数据，网络上的交易系统也是拿 Java 编写
* Hadoop 以及其他大数据处理技术都是用 Java 或者其他，例如 Apache 的基于 Java 的 HBase 和Accumulo 以及 ElasticSearchas。但是 Java 在此领域并未占太大空间
* 采用了freemarker模板引擎，考虑到页面也是要有动态的变化的，所以我们采用spring定时器在每天晚上2点钟的时候定时再次生成html静态页面，考虑发布时候的性能问题，我们又采取线程池技术，让多个线程同时发布，从而缩减发布时间
* 在同一时段,大量的用户集中访问前端页面的资源,流量剧增,导致页面刷新不及时,甚至无法访问,秒杀系统特点是并发量极大,但实际秒杀成功的请求数量却很少,所以如果不在前端拦截很可能造成数据库读写锁冲突,甚至导致死锁,最终请求超时
* 当流量过大的时候，加一个验证码可以在单位时间内有效的控制住合法用户
* 将活动页面上的所有可以静态的元素全部静态化,并尽量减少动态元素,通过CDN来抗峰值
* 户提交之后按钮置灰，禁止重复提交,在某一时间段内只允许用户提交一次请求，比如可以采取IP限流
* 传统秒杀系统之所以挂，请求都压倒了后端数据层，数据读写锁冲突严重，并发高响应慢，几乎所有请求都超时，流量虽大，下单成功的有效流量甚小
* LinkedList中元素位置是任意的，所以执行插入删除操作效率较高，查询效率较低
* 分布式系统架构中，分布式事务问题是一个绕不过去的挑战。而微服务架构的流行，让分布式事问题日益突出
* 跨多个内部服务修改数据
