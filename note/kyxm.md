* https://github.com/roncoo/roncoo-pay?spm=a2c4e.11153940.blogcont69572.17.69e5510asIfpxV
* https://blog.csdn.net/chendaoqiu/article/details/53117870
* Apache POI  处理office文档
* IText    PDF操作
* Base64编码
* pingyin4j  中文转拼音库
* Commons-IO,处理IO
* Commons-beanutils 用来处理javaBean类的反射
* Commons-codec 处理常用加密编码
Commons-collections 对各种集合类
patchca Java验证码
Commons Configuration Java配置文件
cglib java动态代理
com4j 调用com的类库
jsaparjava文本文件处理
dregexp 正则
jegg java多线程开发包
apache mina
jbossnetty
httpclient
boogle guice ioc框架
jboss jbpm工作流引擎开源框架
Drools规则引擎开源框架
date4j
dbunit 数据库测试框架
mockito java mocking框架
joda time 强大易用的日期和时间库


* RocketMq

===
* 应用耦合，异步消息，流量削锋;高性能，高可用，可伸缩和最终一致性架构
* ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ
* 消息队列在实际应用中常用的使用场景。异步处理，应用解耦，流量削锋和消息通讯四个场景
* 订单系统：用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户订单下单成功
* 库存系统：订阅下单的消息，采用拉/推的方式，获取下单信息，库存系统根据下单信息，进行库存操作
* 秒杀活动，一般会因为流量过大，导致流量暴增，应用挂掉。为解决这个问题，一般需要在应用前端加入消息队列
* 日志处理是指将消息队列用在日志处理中，比如Kafka的应用，解决大量日志传输的问题
* (1)Kafka：接收用户日志的消息队列。

(2)Logstash：做日志解析，统一成JSON输出给Elasticsearch。

(3)Elasticsearch：实时日志分析服务的核心技术，一个schemaless，实时的数据存储服务，通过index组织数据，兼具强大的搜索和统计功能。

(4)Kibana：基于Elasticsearch的数据可视化组件，超强的数据可视化能力是众多公司选择ELK stack的重要原因
* Zookeeper注册中心，日志收集客户端，Kafka集群和Storm集群（OtherApp）四部分
* 中文分词插件elasticsearch-analysis-ik
* 提高系统性能首先考虑的是数据库的优化
* 数据库的使用你可能忽略了这些
* 尽量把流量都挡在数据库之前
* 阻隔直达数据库的流量，缓存组件和消息组件是两大杀器
* 持久化确保MQ的使用不只是一个部分场景的辅助工具，而是让MQ能像数据库一样存储核心的数据
* 在现在大流量、大数据的使用场景下，只支持单体应用的服务器软件基本是无法使用的，支持分布式的部署，才能被广泛使用
* MQ 数据是只有一条数据在使用中。 在很多存在并发，而又对数据一致性要求高，而且对性能要求也高的场景，如何保证，那么MQ就能起这个作用了。不管多少流量进来，MQ都会让你遵守规则，排除处理，不会因为其他原因，导致并发的问题，而出现很多意想不到脏数据
* 分布式事务是我们开发中一直尽量避免的一个技术点，但是，现在越来越多的系统是基于微服务架构开发，那么分布式事务成为必须要面对的难题，解决分布式事务有一个比较容易理解的方案，就是二次提交。基于MQ的特点，MQ作为二次提交的中间节点，负责存储请求数据，在失败的情况可以进行多次尝试，或者基于MQ中的队列数据进行回滚操作，是一个既能保证性能，又能保证业务一致性的方案
* 当用户注册成功过后，通过MQ通知其他业务进行操作。确保注册用户的性能
* 后台发布商品的时候，商品数据需要从数据库中转换成搜索引擎数据（基于elasticsearch），那么我们应该将商品写入数据库后，再写入到MQ，然后通过监听MQ来生成elasticsearch对应的数据
* 用户下单后，24小时未支付，需要取消订单。以前我们可能是定时任务循环查询，然后取消订单。实际上，我更推荐类似延迟MQ的方式，避免了很多无效的数据库查询，将一个MQ设置为24小时后才让消费者消费掉，这样很大程度上能减轻服务器压力
* 支付完成后，需要及时的通知子系统（进销存系统发货，用户服务积分，发送短信）进行下一步操作，但是，支付回调我们都是需要保证高性能的，所以，我应该直接修改数据库状态，存入MQ，让MQ通知子系统做其他非实时的业务操作
* 任何一个技术的出现，都有他的业务场景，只有清楚技术的特点，才能更加贴切的挖掘出应用场景，深入思考，深入实践才能将一个技术用在最合适的地方
* 数据库的管理是一个非常专业的事情，对数据库的调优、监控一般是由数据库工程师完成，但是开发人员也经常与数据库打交道，即使是简单的增删改查也是有很多窍门
* 字段长度对索引的影响是很大的
* 字符串字段长度都差不多的，可以预估长度的，用char
字符串长度差异大，用varchar,限制长度，不要浪费空间
整型根据大小，选择合适的类型
时间建议用timestamp
建议使用decimal，不建议使用float,如果是价格，可以考虑用int或bigint，如1元，存储的就是100
* 大表减少联表，最好是单表查询
* 合理的冗余字段
配合内存数据库（redis\mongodb）使用
联表变多次查询（下文会有说明）
* 如果考虑都后期数据量大，需要分表分库，就应该尽早实时单表查询，现在的数据库分表分库的中间件基本都无法支持联表查询
* 一个表的索引不宜过多，建议最多就5个，索引不可能满足所有的场景，但是了个满足绝大部分的场景
* 聚合操作如count,group等，是数据库性能的大杀手，经常会出现大面积的表扫描和索表的情况
* 避免聚合操作的方法就是将实时的count计算结果用字段去存储，去累加这个结果。当然，也可以考虑用spark等实时计算框架去处理，这种高深的技术
* 阿里SQL的规范有很多可以吸取的地方
